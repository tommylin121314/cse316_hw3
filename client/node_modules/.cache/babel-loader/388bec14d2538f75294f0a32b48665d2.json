{"ast":null,"code":"export class jsTPS_Transaction {\n  constructor() {}\n\n  doTransaction() {}\n\n  undoTransaction() {}\n\n}\n/*  Handles list name changes, or any other top level details of a todolist that may be added   */\n\nexport class UpdateListField_Transaction extends jsTPS_Transaction {\n  constructor(_id, field, prev, update, callback) {\n    super();\n    this.prev = prev;\n    this.update = update;\n    this.field = field;\n    this._id = _id;\n    this.updateFunction = callback;\n  }\n\n  async doTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        _id: this._id,\n        field: this.field,\n        value: this.update\n      }\n    });\n    return data;\n  }\n\n  async undoTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        _id: this._id,\n        field: this.field,\n        value: this.prev\n      }\n    });\n    return data;\n  }\n\n}\n/*  Handles item reordering */\n\nexport class ReorderItems_Transaction extends jsTPS_Transaction {\n  constructor(listID, itemID, dir, callback) {\n    super();\n    this.listID = listID;\n    this.itemID = itemID;\n    this.dir = dir;\n    this.revDir = dir === 1 ? -1 : 1;\n    this.updateFunction = callback;\n  }\n\n  async doTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID,\n        direction: this.dir\n      }\n    });\n    return data;\n  }\n\n  async undoTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID,\n        direction: this.revDir\n      }\n    });\n    return data;\n  }\n\n}\nexport class EditItem_Transaction extends jsTPS_Transaction {\n  constructor(listID, itemID, field, prev, update, flag, callback) {\n    super();\n    this.listID = listID;\n    this.itemID = itemID;\n    this.field = field;\n    this.prev = prev;\n    this.update = update;\n    this.flag = flag;\n    this.updateFunction = callback;\n  }\n\n  async doTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID,\n        field: this.field,\n        value: this.update,\n        flag: this.flag\n      }\n    });\n    return data;\n  }\n\n  async undoTransaction() {\n    const {\n      data\n    } = await this.updateFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID,\n        field: this.field,\n        value: this.prev,\n        flag: this.flag\n      }\n    });\n    return data;\n  }\n\n}\n/*  Handles create/delete of list items */\n\nexport class UpdateListItems_Transaction extends jsTPS_Transaction {\n  // opcodes: 0 - delete, 1 - add \n  constructor(listID, itemID, item, opcode, addfunc, delfunc) {\n    super();\n    this.listID = listID;\n    this.itemID = itemID;\n    this.item = item;\n    this.addFunction = addfunc;\n    this.deleteFunction = delfunc;\n    this.opcode = opcode;\n  }\n\n  async doTransaction() {\n    let data;\n    this.opcode === 0 ? ({\n      data\n    } = await this.deleteFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID\n      }\n    })) : ({\n      data\n    } = await this.addFunction({\n      variables: {\n        item: this.item,\n        _id: this.listID\n      }\n    }));\n\n    if (this.opcode !== 0) {\n      this.item._id = this.itemID = data.addItem;\n    }\n\n    return data;\n  } // Since delete/add are opposites, flip matching opcode\n\n\n  async undoTransaction() {\n    let data;\n    this.opcode === 1 ? ({\n      data\n    } = await this.deleteFunction({\n      variables: {\n        itemId: this.itemID,\n        _id: this.listID\n      }\n    })) : ({\n      data\n    } = await this.addFunction({\n      variables: {\n        item: this.item,\n        _id: this.listID\n      }\n    }));\n\n    if (this.opcode !== 1) {\n      this.item._id = this.itemID = data.addItem;\n    }\n\n    return data;\n  }\n\n}\nexport class jsTPS {\n  constructor() {\n    // THE TRANSACTION STACK\n    this.transactions = []; // KEEPS TRACK OF WHERE WE ARE IN THE STACK, THUS AFFECTING WHAT\n    // TRANSACTION MAY BE DONE OR UNDONE AT ANY GIVEN TIME\n\n    this.mostRecentTransaction = -1; // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n    // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n\n    this.performingDo = false;\n    this.performingUndo = false;\n  }\n  /**\n   * Tests to see if the do (i.e. redo) operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * return true if the do (i.e. redo) operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingDo() {\n    return this.performingDo;\n  }\n  /**\n   * Tests to see if the undo operation is currently being\n   * performed. If it is, true is returned, if not, false.\n   * \n   * return true if the undo operation is currently in the\n   * process of executing, false otherwise.\n   */\n\n\n  isPerformingUndo() {\n    return this.performingUndo;\n  }\n  /**\n   * This function adds the transaction argument to the top of\n   * the transaction processing system stack and then executes it. Note that it does\n   * When this method has completed transaction will be at the top \n   * of the stack, it will have been completed, and the counter have\n   * been moved accordingly.\n   * \n   * param transaction The custom transaction to be added to\n   * the transaction processing system stack and executed.\n   */\n\n\n  addTransaction(transaction) {\n    // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n    // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n    if (this.mostRecentTransaction < 0 || this.mostRecentTransaction < this.transactions.length - 1) {\n      for (let i = this.transactions.length - 1; i > this.mostRecentTransaction; i--) {\n        this.transactions.splice(i, 1);\n      }\n    } // AND NOW ADD THE TRANSACTION\n\n\n    this.transactions.push(transaction); // AND EXECUTE IT\n    // this.doTransaction();        \n  }\n  /**\n   * This function executes the transaction at the location of the counter,\n   * then moving the TPS counter. Note that this may be the transaction\n   * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n   */\n\n\n  async doTransaction() {\n    let retVal;\n\n    if (this.hasTransactionToRedo()) {\n      this.performingDo = true;\n      let transaction = this.transactions[this.mostRecentTransaction + 1];\n      retVal = await transaction.doTransaction();\n      this.mostRecentTransaction++;\n      this.performingDo = false;\n    }\n\n    console.log('transactions: ' + this.getSize());\n    console.log('redo transactions:' + this.getRedoSize());\n    console.log('undo transactions:' + this.getUndoSize());\n    console.log(' ');\n    return retVal;\n  }\n  /**\n   * This function checks to see if there is a transaction to undo. If there\n   * is it will return it, if not, it will return null.\n   * \n   * return The transaction that would be executed if undo is performed, if\n   * there is no transaction to undo, null is returned.\n   */\n\n\n  peekUndo() {\n    if (this.hasTransactionToUndo()) {\n      return this.transactions[this.mostRecentTransaction];\n    } else return null;\n  }\n  /**\n   * This function checks to see if there is a transaction to redo. If there\n   * is it will return it, if not, it will return null.\n   * \n   * return The transaction that would be executed if redo is performed, if\n   * there is no transaction to undo, null is returned.\n   */\n\n\n  peekDo() {\n    if (this.hasTransactionToRedo()) {\n      return this.transactions[this.mostRecentTransaction + 1];\n    } else return null;\n  }\n  /**\n   * This function gets the most recently executed transaction on the \n   * TPS stack and undoes it, moving the TPS counter accordingly.\n   */\n\n\n  async undoTransaction() {\n    let retVal;\n\n    if (this.hasTransactionToUndo()) {\n      this.performingUndo = true;\n      let transaction = this.transactions[this.mostRecentTransaction];\n      retVal = await transaction.undoTransaction();\n      this.mostRecentTransaction--;\n      this.performingUndo = false;\n    }\n\n    console.log('transactions: ' + this.getSize());\n    console.log('redo transactions:' + this.getRedoSize());\n    console.log('undo transactions:' + this.getUndoSize());\n    console.log(' ');\n    return retVal;\n  }\n  /**\n   * This method clears all transactions from the TPS stack\n   * and resets the counter that keeps track of the location\n   * of the top of the stack.\n   */\n\n\n  clearAllTransactions() {\n    // REMOVE ALL THE TRANSACTIONS\n    this.transactions = []; // MAKE SURE TO RESET THE LOCATION OF THE\n    // TOP OF THE TPS STACK TOO\n\n    this.mostRecentTransaction = -1;\n  }\n  /**\n   * Accessor method that returns the number of transactions currently\n   * on the transaction stack. This includes those that may have been\n   * done, undone, and redone.\n   * \n   * return The number of transactions currently in the transaction stack.\n   */\n\n\n  getSize() {\n    return this.transactions.length;\n  }\n  /**\n   * This method returns the number of transactions currently in the\n   * transaction stack that can be redone, meaning they have been added\n   * and done, and then undone.\n   * \n   * return The number of transactions in the stack that can be redone.\n   */\n\n\n  getRedoSize() {\n    return this.getSize() - this.mostRecentTransaction - 1;\n  }\n  /**\n   * This method returns the number of transactions currently in the \n   * transaction stack that can be undone.\n   * \n   * return The number of transactions in the transaction stack that\n   * can be undone.\n   */\n\n\n  getUndoSize() {\n    return this.mostRecentTransaction + 1;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be undone at the time this function is called.\n   * \n   * return true if an undo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToUndo() {\n    return this.mostRecentTransaction >= 0;\n  }\n  /**\n   * This method tests to see if there is a transaction on the stack that\n   * can be redone at the time this function is called.\n   * \n   * return true if a redo operation is possible, false otherwise.\n   */\n\n\n  hasTransactionToRedo() {\n    return this.mostRecentTransaction < this.transactions.length - 1;\n  }\n  /**\n   * This method builds and returns a textual summary of the current\n   * Transaction Processing System, this includes the toString of\n   * each transaction in the stack.\n   * \n   * return A textual summary of the TPS.\n   */\n  // toString() {\n  //     let text = \"<br>\" +\"--Number of Transactions: \" + this.transactions.length + \"</br>\";\n  //     text += \"<br>\" + \"--Current Index on Stack: \" + this.mostRecentTransaction + \"</br>\";\n  //     text += \"<br>\" + \"--Current Transaction Stack:\" + \"</br>\";\n  //     for (let i = 0; i <= this.mostRecentTransaction; i++) {\n  //         let jsT = this.transactions[i];\n  //         text += \"<br>\" + \"----\" + jsT.toString() + \"</br>\";\n  //     }\n  //     return text;\n  // }\n\n\n}","map":{"version":3,"sources":["/Users/tommylin/Desktop/CSE316/cse316_hw3/client/src/utils/jsTPS.js"],"names":["jsTPS_Transaction","constructor","doTransaction","undoTransaction","UpdateListField_Transaction","_id","field","prev","update","callback","updateFunction","data","variables","value","ReorderItems_Transaction","listID","itemID","dir","revDir","itemId","direction","EditItem_Transaction","flag","UpdateListItems_Transaction","item","opcode","addfunc","delfunc","addFunction","deleteFunction","addItem","jsTPS","transactions","mostRecentTransaction","performingDo","performingUndo","isPerformingDo","isPerformingUndo","addTransaction","transaction","length","i","splice","push","retVal","hasTransactionToRedo","console","log","getSize","getRedoSize","getUndoSize","peekUndo","hasTransactionToUndo","peekDo","clearAllTransactions"],"mappings":"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","sourcesContent":["export class jsTPS_Transaction {\n    constructor() {};\n    doTransaction() {};\n    undoTransaction () {};\n}\n/*  Handles list name changes, or any other top level details of a todolist that may be added   */\nexport class UpdateListField_Transaction extends jsTPS_Transaction {\n    constructor(_id, field, prev, update, callback) {\n        super();\n        this.prev = prev;\n        this.update = update;\n        this.field = field;\n        this._id = _id;\n        this.updateFunction = callback;\n    }\n    async doTransaction() {\n\t\tconst { data } = await this.updateFunction({ variables: { _id: this._id, field: this.field, value: this.update }});\n\t\treturn data;\n    }\n    async undoTransaction() {\n        const { data } = await this.updateFunction({ variables: { _id: this._id, field: this.field, value: this.prev }});\n\t\treturn data;\n    }\n}\n\n/*  Handles item reordering */\nexport class ReorderItems_Transaction extends jsTPS_Transaction {\n    constructor(listID, itemID, dir, callback) {\n        super();\n        this.listID = listID;\n        this.itemID = itemID;\n\t\tthis.dir = dir;\n\t\tthis.revDir = dir === 1 ? -1 : 1;\n\t\tthis.updateFunction = callback;\n\t}\n\n    async doTransaction() {\n\t\tconst { data } = await this.updateFunction({ variables: { itemId: this.itemID, _id: this.listID, direction: this.dir }});\n\t\treturn data;\n    }\n\n    async undoTransaction() {\n\t\tconst {data} = await this.updateFunction({ variables: { itemId: this.itemID, _id: this.listID, direction: this.revDir }});\n\t\treturn data;\n\n    }\n    \n}\n\nexport class EditItem_Transaction extends jsTPS_Transaction {\n\tconstructor(listID, itemID, field, prev, update, flag, callback) {\n\t\tsuper();\n\t\tthis.listID = listID;\n\t\tthis.itemID = itemID;\n\t\tthis.field = field;\n\t\tthis.prev = prev;\n\t\tthis.update = update;\n\t\tthis.flag = flag;\n\t\tthis.updateFunction = callback;\n\t}\t\n\n\tasync doTransaction() {\n\t\tconst { data } = await this.updateFunction({ \n\t\t\t\tvariables:{  itemId: this.itemID, _id: this.listID, \n\t\t\t\t\t\t\t field: this.field, value: this.update, \n\t\t\t\t\t\t\t flag: this.flag \n\t\t\t\t\t\t  }\n\t\t\t});\n\t\treturn data;\n    }\n\n    async undoTransaction() {\n\t\tconst { data } = await this.updateFunction({ \n\t\t\t\tvariables:{ itemId: this.itemID, _id: this.listID, \n\t\t\t\t\t\t\tfield: this.field, value: this.prev, \n\t\t\t\t\t\t\tflag: this.flag \n\t\t\t\t\t\t  }\n\t\t\t});\n\t\treturn data;\n\n    }\n}\n\n/*  Handles create/delete of list items */\nexport class UpdateListItems_Transaction extends jsTPS_Transaction {\n    // opcodes: 0 - delete, 1 - add \n    constructor(listID, itemID, item, opcode, addfunc, delfunc) {\n        super();\n        this.listID = listID;\n\t\tthis.itemID = itemID;\n\t\tthis.item = item;\n        this.addFunction = addfunc;\n        this.deleteFunction = delfunc;\n        this.opcode = opcode;\n    }\n    async doTransaction() {\n\t\tlet data;\n        this.opcode === 0 ? { data } = await this.deleteFunction({\n\t\t\t\t\t\t\tvariables: {itemId: this.itemID, _id: this.listID}})\n\t\t\t\t\t\t  : { data } = await this.addFunction({\n\t\t\t\t\t\t\tvariables: {item: this.item, _id: this.listID}})  \n\t\tif(this.opcode !== 0) {\n            this.item._id = this.itemID = data.addItem;\n\t\t}\n\t\treturn data;\n    }\n    // Since delete/add are opposites, flip matching opcode\n    async undoTransaction() {\n\t\tlet data;\n        this.opcode === 1 ? { data } = await this.deleteFunction({\n\t\t\t\t\t\t\tvariables: {itemId: this.itemID, _id: this.listID}})\n                          : { data } = await this.addFunction({\n\t\t\t\t\t\t\tvariables: {item: this.item, _id: this.listID}})\n\t\tif(this.opcode !== 1) {\n            this.item._id = this.itemID = data.addItem;\n        }\n\t\treturn data;\n    }\n}\n\n\n\n\nexport class jsTPS {\n    constructor() {\n        // THE TRANSACTION STACK\n        this.transactions = [];\n        // KEEPS TRACK OF WHERE WE ARE IN THE STACK, THUS AFFECTING WHAT\n        // TRANSACTION MAY BE DONE OR UNDONE AT ANY GIVEN TIME\n        this.mostRecentTransaction = -1;\n        // THESE VARIABLES CAN BE TURNED ON AND OFF TO SIGNAL THAT\n        // DO AND UNDO OPERATIONS ARE BEING PERFORMED\n        this.performingDo = false;\n        this.performingUndo = false;\n    }\n    \n    /**\n     * Tests to see if the do (i.e. redo) operation is currently being\n     * performed. If it is, true is returned, if not, false.\n     * \n     * return true if the do (i.e. redo) operation is currently in the\n     * process of executing, false otherwise.\n     */\n    isPerformingDo() {\n        return this.performingDo;\n    }\n    \n    /**\n     * Tests to see if the undo operation is currently being\n     * performed. If it is, true is returned, if not, false.\n     * \n     * return true if the undo operation is currently in the\n     * process of executing, false otherwise.\n     */\n    isPerformingUndo() {\n        return this.performingUndo;\n    }\n    \n    /**\n     * This function adds the transaction argument to the top of\n     * the transaction processing system stack and then executes it. Note that it does\n     * When this method has completed transaction will be at the top \n     * of the stack, it will have been completed, and the counter have\n     * been moved accordingly.\n     * \n     * param transaction The custom transaction to be added to\n     * the transaction processing system stack and executed.\n     */\n    addTransaction(transaction) {\n        // ARE THERE OLD UNDONE TRANSACTIONS ON THE STACK THAT FIRST\n        // NEED TO BE CLEARED OUT, i.e. ARE WE BRANCHING?\n        if ((this.mostRecentTransaction < 0)|| (this.mostRecentTransaction < (this.transactions.length-1))) {\n            for (let i = this.transactions.length-1; i > this.mostRecentTransaction; i--) {\n                this.transactions.splice(i, 1);\n            }\n        }\n\n        // AND NOW ADD THE TRANSACTION\n        this.transactions.push(transaction);\n        // AND EXECUTE IT\n        // this.doTransaction();        \n    }\n\n    /**\n     * This function executes the transaction at the location of the counter,\n     * then moving the TPS counter. Note that this may be the transaction\n     * at the top of the TPS stack or somewhere in the middle (i.e. a redo).\n     */\n     async doTransaction() {\n\t\tlet retVal;\n        if (this.hasTransactionToRedo()) {   \n            this.performingDo = true;\n            let transaction = this.transactions[this.mostRecentTransaction+1];\n\t\t\tretVal = await transaction.doTransaction();\n\t\t\tthis.mostRecentTransaction++;\n\t\t\tthis.performingDo = false;\n            \n        }\n        console.log('transactions: ' + this.getSize());\n        console.log('redo transactions:' + this.getRedoSize());\n        console.log('undo transactions:' + this.getUndoSize());\n\t\tconsole.log(' ')\n\t\treturn retVal;\n    }\n    \n    /**\n     * This function checks to see if there is a transaction to undo. If there\n     * is it will return it, if not, it will return null.\n     * \n     * return The transaction that would be executed if undo is performed, if\n     * there is no transaction to undo, null is returned.\n     */\n    peekUndo() {\n        if (this.hasTransactionToUndo()) {\n            return this.transactions[this.mostRecentTransaction];\n        }\n        else\n            return null;\n    }\n    \n    /**\n     * This function checks to see if there is a transaction to redo. If there\n     * is it will return it, if not, it will return null.\n     * \n     * return The transaction that would be executed if redo is performed, if\n     * there is no transaction to undo, null is returned.\n     */    \n    peekDo() {\n        if (this.hasTransactionToRedo()) {\n            return this.transactions[this.mostRecentTransaction+1];\n        }\n        else\n            return null;\n    }\n\n    /**\n     * This function gets the most recently executed transaction on the \n     * TPS stack and undoes it, moving the TPS counter accordingly.\n     */\n     async undoTransaction() {\n\t\tlet retVal;\n        if (this.hasTransactionToUndo()) {\n            this.performingUndo = true;\n            let transaction = this.transactions[this.mostRecentTransaction];\n\t\t\tretVal = await transaction.undoTransaction();\n            this.mostRecentTransaction--;\n\t\t\tthis.performingUndo = false;\n        }\n        console.log('transactions: ' + this.getSize());\n        console.log('redo transactions:' + this.getRedoSize());\n        console.log('undo transactions:' + this.getUndoSize());\n        console.log(' ')\n\t\treturn(retVal);\n    }\n\n    /**\n     * This method clears all transactions from the TPS stack\n     * and resets the counter that keeps track of the location\n     * of the top of the stack.\n     */\n    clearAllTransactions() {\n        // REMOVE ALL THE TRANSACTIONS\n        this.transactions = [];\n        \n        // MAKE SURE TO RESET THE LOCATION OF THE\n        // TOP OF THE TPS STACK TOO\n        this.mostRecentTransaction = -1;        \n    }\n    \n    /**\n     * Accessor method that returns the number of transactions currently\n     * on the transaction stack. This includes those that may have been\n     * done, undone, and redone.\n     * \n     * return The number of transactions currently in the transaction stack.\n     */\n    getSize() {\n        return this.transactions.length;\n    }\n    \n    /**\n     * This method returns the number of transactions currently in the\n     * transaction stack that can be redone, meaning they have been added\n     * and done, and then undone.\n     * \n     * return The number of transactions in the stack that can be redone.\n     */\n    getRedoSize() {\n        return this.getSize() - this.mostRecentTransaction - 1;\n    }\n\n    /**\n     * This method returns the number of transactions currently in the \n     * transaction stack that can be undone.\n     * \n     * return The number of transactions in the transaction stack that\n     * can be undone.\n     */\n    getUndoSize() {\n        return this.mostRecentTransaction + 1;\n    }\n    \n    /**\n     * This method tests to see if there is a transaction on the stack that\n     * can be undone at the time this function is called.\n     * \n     * return true if an undo operation is possible, false otherwise.\n     */\n    hasTransactionToUndo() {\n        return this.mostRecentTransaction >= 0;\n    }\n    \n    /**\n     * This method tests to see if there is a transaction on the stack that\n     * can be redone at the time this function is called.\n     * \n     * return true if a redo operation is possible, false otherwise.\n     */\n    hasTransactionToRedo() {\n        return this.mostRecentTransaction < (this.transactions.length-1);\n    }\n        \n    /**\n     * This method builds and returns a textual summary of the current\n     * Transaction Processing System, this includes the toString of\n     * each transaction in the stack.\n     * \n     * return A textual summary of the TPS.\n     */\n    // toString() {\n    //     let text = \"<br>\" +\"--Number of Transactions: \" + this.transactions.length + \"</br>\";\n    //     text += \"<br>\" + \"--Current Index on Stack: \" + this.mostRecentTransaction + \"</br>\";\n    //     text += \"<br>\" + \"--Current Transaction Stack:\" + \"</br>\";\n    //     for (let i = 0; i <= this.mostRecentTransaction; i++) {\n    //         let jsT = this.transactions[i];\n    //         text += \"<br>\" + \"----\" + jsT.toString() + \"</br>\";\n    //     }\n    //     return text;\n    // }\n}"]},"metadata":{},"sourceType":"module"}